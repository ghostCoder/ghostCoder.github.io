{"version":3,"file":"static/js/97.6476adf9.chunk.js","mappings":"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","sources":["utilities/prQueries/QUERY_PR_ASSIGNEES.ts","utilities/getAdditionalData.ts","utilities/tokenValidationUtilities/getters/getAtlassianAccessTokenValue.ts","components/prTabs/tabs/AddData.tsx","utilities/getIssueKeysFromPRTitle.ts"],"sourcesContent":["import { DocumentNode, gql } from \"@apollo/client\";\n\nexport const QUERY_PR_ASSIGNEES: DocumentNode = gql`\n  query PRAssignees($id: MergeRequestID!) {\n    mergeRequest(id: $id) {\n      assignees {\n        nodes {\n          name\n          username\n        }\n      }\n    }\n  }\n`;\n","import { getAtlassianAccessTokenValue } from \"./tokenValidationUtilities/getters/getAtlassianAccessTokenValue\";\nimport { refreshAtlassianTokens } from \"./tokenValidationUtilities/refreshAtlassianTokens\";\nimport { validateGitLabToken } from \"./tokenValidationUtilities/validateGitLabToken\";\nimport { getIssueKeysFromPRTitle } from \"./getIssueKeysFromPRTitle\";\nimport { clientAtlassian, clientGitLab } from \"./queryClients\";\nimport { JIRA_LABELS_ENDPOINT, PR } from \"./constants\";\nimport { QUERY_PR_ASSIGNEES } from \"./prQueries/QUERY_PR_ASSIGNEES\";\n\nconst fetchJiraLabels = async (issueKey: string): Promise<string[]> => {\n  try {\n    const response = await fetch(\n      JIRA_LABELS_ENDPOINT +\n        issueKey +\n        \"?\" +\n        new URLSearchParams({\n          fields: \"labels\",\n        }),\n      {\n        method: \"GET\",\n        headers: {\n          Authorization: `Bearer ${getAtlassianAccessTokenValue()}`,\n        },\n      }\n    );\n    const data = await response.json();\n    return data.fields === undefined ? [] : data.fields?.labels;\n  } catch (error) {\n    throw error;\n  }\n};\n\nexport const getAdditionalData = async (\n  data: PR[],\n  setAtlassianInCache: React.Dispatch<React.SetStateAction<boolean>>,\n  setGitInCache: React.Dispatch<React.SetStateAction<boolean>>,\n  setNetworkError: React.Dispatch<React.SetStateAction<boolean>>\n): Promise<PR[] | void> => {\n  try {\n    const response = await validateGitLabToken();\n    console.log(\"GitLab PAT validated: \", response);\n  } catch (error) {\n    console.log(\"GitLab PAT validation failed: \", error);\n    if (String(error).startsWith(\"TypeError: Failed to fetch\")) {\n      setNetworkError(true);\n    } else {\n      setGitInCache(false);\n    }\n  }\n  try {\n    const response = await refreshAtlassianTokens();\n    console.log(\"Atlassian access token refreshed: \", response);\n    for (let pr of data) {\n      const issueKeys = getIssueKeysFromPRTitle(pr.title);\n      if (pr.assignees === undefined) {\n        try {\n          const response = await clientGitLab.query({\n            query: QUERY_PR_ASSIGNEES,\n            variables: {\n              id: pr.id,\n            },\n            fetchPolicy: \"cache-first\",\n          });\n          pr.assignees =\n            response.data.mergeRequest === null\n              ? { nodes: [] }\n              : response.data.mergeRequest.assignees;\n        } catch (error) {\n          pr.assignees = { nodes: [] };\n          console.log(\n            `Error fetching assignees for PR with ID ${pr.id}`,\n            error\n          );\n        }\n      }\n      pr.jiraLabels = [];\n      for (let issueKey of issueKeys) {\n        try {\n          const jiraLabels = await clientAtlassian.fetchQuery({\n            queryKey: [\"Jira Labels\", issueKey],\n            queryFn: () => fetchJiraLabels(issueKey),\n            staleTime: 30000,\n            cacheTime: 600000,\n          });\n          pr.jiraLabels = [...new Set([...pr.jiraLabels, ...jiraLabels])];\n        } catch (error) {\n          pr.jiraLabels = [];\n          console.log(\n            JSON.stringify({\n              error_message: `Error retrieving Jira labels for issue with issue key: ${issueKey}`,\n              error: error,\n            })\n          );\n        }\n      }\n    }\n    return data;\n  } catch (error) {\n    console.log(\"Error refreshing atlassian token from cache: \", error);\n    if (String(error).startsWith(\"TypeError: Failed to fetch\")) {\n      setNetworkError(true);\n    } else {\n      setAtlassianInCache(false);\n    }\n  }\n};\n","import { TEAMS_CONFIG } from \"../../constants\";\n\nexport const getAtlassianAccessTokenValue = (): string | null => {\n  return localStorage.getItem(\n    `${TEAMS_CONFIG.CLIENT_ID}:atlassian-access-token`\n  );\n};\n","import React, { useState, useEffect, useContext, Suspense } from \"react\";\nimport { getAdditionalData } from \"../../../utilities/getAdditionalData\";\nimport { TokensInCacheContext } from \"../../../contexts/Context\";\nimport { TAB_TYPE, PR } from \"../../../utilities/constants\";\nimport { Loading } from \"../../Loading\";\n\nexport const AddData = ({\n  data: dataNoJiraLabels,\n  tabType,\n}: {\n  data: PR[];\n  tabType: string;\n}) => {\n  const [dataLoading, setDataLoading] = useState<boolean>(true);\n  const { setAtlassianInCache, setGitInCache, setNetworkError } =\n    useContext(TokensInCacheContext);\n\n  const [data, setData] = useState<PR[] | void>(dataNoJiraLabels);\n\n  useEffect(() => {\n    if (dataLoading) {\n      (async () => {\n        const response = await getAdditionalData(\n          JSON.parse(JSON.stringify(dataNoJiraLabels)),\n          setAtlassianInCache!,\n          setGitInCache!,\n          setNetworkError!\n        );\n        setData(response);\n        setDataLoading(false);\n      })();\n    }\n  }, [\n    dataLoading,\n    dataNoJiraLabels,\n    setAtlassianInCache,\n    setGitInCache,\n    setNetworkError,\n  ]);\n\n  const DisplayPRs = React.lazy(() =>\n    import(\"./displayPRs/DisplayPRs\").then((module) => ({\n      default: module.DisplayPRs,\n    }))\n  );\n\n  const Error = React.lazy(() =>\n    import(\"../../Error\").then((module) => ({\n      default: module.Error,\n    }))\n  );\n\n  switch (tabType) {\n    case TAB_TYPE.myPRs:\n      return (\n        <Suspense fallback={<Loading loadingText=\"Loading My PR's tab...\" />}>\n          <DisplayPRs data={data as PR[]} tabType={tabType} />\n        </Suspense>\n      );\n    case TAB_TYPE.reviewRequested:\n      return (\n        <Suspense\n          fallback={\n            <Loading loadingText=\"Loading Review requested PR's tab...\" />\n          }\n        >\n          <DisplayPRs data={data as PR[]} tabType={tabType} />\n        </Suspense>\n      );\n    case TAB_TYPE.groupPRs:\n      return (\n        <Suspense\n          fallback={<Loading loadingText=\"Loading Group PR's tab...\" />}\n        >\n          <DisplayPRs data={data as PR[]} tabType={tabType} />\n        </Suspense>\n      );\n    case TAB_TYPE.groupsMergedPRs:\n      return (\n        <Suspense\n          fallback={<Loading loadingText=\"Loading Groups merged PR's tab...\" />}\n        >\n          <DisplayPRs data={data as PR[]} tabType={tabType} />\n        </Suspense>\n      );\n    default:\n      return (\n        <Suspense fallback={<Loading loadingText=\"\" />}>\n          <Error errorMessage=\"\" />\n        </Suspense>\n      );\n  }\n};\n","export const getIssueKeysFromPRTitle = (prTitle: string) => {\n  let issueKeys: string[] = [];\n\n  if (prTitle[0] === \"[\") {\n    let start = 0;\n    do {\n      let flag = 0;\n      start += 1;\n      if (prTitle[start] === \"|\") {\n        start++;\n      }\n      while (prTitle[start] === \" \") {\n        start++;\n        if (start === prTitle.length || prTitle[start] === \"]\") {\n          flag = 2;\n          break;\n        } else if (prTitle[start] === \"|\") {\n          flag = 1;\n        }\n      }\n      if (flag === 2) {\n        break;\n      } else if (flag === 1) {\n        continue;\n      }\n      let end = start + 1;\n      while (\n        prTitle[end] !== \" \" &&\n        prTitle[end] !== \"|\" &&\n        prTitle[end] !== \"]\"\n      ) {\n        end++;\n      }\n      issueKeys = [...issueKeys, prTitle.slice(start, end)];\n      start = end;\n    } while (prTitle[start] !== \"]\");\n  }\n  return issueKeys;\n};\n"],"names":["QUERY_PR_ASSIGNEES","gql","_templateObject","_taggedTemplateLiteral","fetchJiraLabels","async","_data$fields","response","fetch","JIRA_LABELS_ENDPOINT","issueKey","URLSearchParams","fields","method","headers","Authorization","concat","localStorage","getItem","TEAMS_CONFIG","CLIENT_ID","data","json","undefined","labels","error","AddData","_ref","dataNoJiraLabels","tabType","dataLoading","setDataLoading","useState","setAtlassianInCache","setGitInCache","setNetworkError","useContext","TokensInCacheContext","setData","useEffect","validateGitLabToken","console","log","String","startsWith","refreshAtlassianTokens","pr","issueKeys","getIssueKeysFromPRTitle","title","assignees","clientGitLab","query","variables","id","fetchPolicy","mergeRequest","nodes","jiraLabels","clientAtlassian","fetchQuery","queryKey","queryFn","staleTime","cacheTime","Set","JSON","stringify","error_message","getAdditionalData","parse","DisplayPRs","React","then","module","default","Error","TAB_TYPE","myPRs","_jsx","Suspense","fallback","Loading","loadingText","children","reviewRequested","groupPRs","groupsMergedPRs","errorMessage","prTitle","start","flag","length","end","slice"],"sourceRoot":""}